#!/usr/bin/env python3

###############################################################
# tcluster - open/close/restart a tunnel to cluster machines
###############################################################

import os
import subprocess as sp
from shlex import split
from getpass import getuser
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter


clusters = ['discover', 'orion', 'devwcoss', 'prodwcoss', 'cheyenne']


class Tunnel(object):

    def __init__(self, machine):

        self.machine = machine
        self.__checkStatus()

    def __str__(self):
        pass

    def __repr__(self):
        pass

    @property
    def isOpen(self):
        status = False
        if self.__plist:
            for pid in self.__plist:
                status = True

        return status

    def __checkStatus(self):

        try:
            proc1 = sp.Popen(split('ps x'), stdout=sp.PIPE)
            proc2 = sp.Popen(split('grep -e "-YMNfq %s"' % self.machine),
                             stdin=proc1.stdout, stdout=sp.PIPE, stderr=sp.PIPE)
            proc3 = sp.Popen(split('grep -v grep'),
                             stdin=proc2.stdout, stdout=sp.PIPE, stderr=sp.PIPE)
            proc4 = sp.Popen(split('awk "{print $1}"'),
                             stdin=proc3.stdout, stdout=sp.PIPE, stderr=sp.PIPE)

            proc1.stdout.close()
            proc2.stdout.close()
            proc3.stdout.close()
            o, e = proc4.communicate()
        except:
            print("An exception occurred in checkStatus")
            raise SystemExit()

        plist = []
        if o:
            lines = o.decode().split('\n')
            if (lines[0][0:4] == 'dyld'):
                plist = lines[1:-1]
            else:
                plist = lines[:-1]

        self.__plist = plist

        return

    @property
    def create(self):

        self.__rmMasterFile()
        try:
            sp.call(['ssh', '-YMNfq', '%s' % self.machine])
        except:
            raise OSError(f"tunnel to {self.machine} was not created")

        return

    @property
    def close(self):

        print(f"closing tunnel to {self.machine}")
        if self.__plist:
            for pid in self.__plist:
                try:
                    sp.call(['kill', '%s' % pid])
                except:
                    raise OSError(f"tunnel to {self.machine} could not be closed through process id {pid}")
            self.__rmMasterFile
        else:
            print(f"No tunnels open to {self.machine}")

        return

    @property
    def list(self):

        if self.__plist:
            for pid in self.__plist:
                print(
                    f"Tunnel to {self.machine} is running as process id {pid}")
        else:
            print(f"No tunnels open to {self.machine}")

        return

    @property
    def __getMasterFileName(self):
        masterFile = f"{os.environ['HOME']}/.ssh/master-{getuser()}@{self.machine}:22"
        return masterFile

    @property
    def __rmMasterFile(self):
        masterFile = self.__getMasterFileName
        if (os.path.exists(masterFile)):
            try:
                sp.call(['rm', '-f', masterFile])
            except:
                raise OSError(f"Failed to remove master file {masterFile} for machine {self.machine}")
        return


def main():

    parser = ArgumentParser(description='Open / close / list tunnels to cluster machines',
                            formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument('-m', '--machine', help='machine name',
                        type=str, required=True, choices=clusters)
    parser.add_argument('-r', '--restart', help='restart existing tunnel',
                        action='store_true', required=False)
    parser.add_argument('-k', '--kill',   help='close existing tunnel',
                        action='store_true', required=False)
    parser.add_argument('-l', '--list',   help='list all open tunnels',
                        action='store_true', required=False)
    parser.add_argument('-c', '--clean',   help='clean tunnel socket',
                        action='store_true', required=False)
    args = parser.parse_args()

    tmachine = Tunnel(args.machine)

    if args.list:
        tmachine.list
        return

    if args.kill or args.clean or args.restart:
        tmachine.close
        if args.restart:
            tmachine.create
        return

    if tmachine.isOpen:
        print(f"Tunnel to {machine} is already open, use it!")
        raise SystemExit()

    tmachine.create

    return


if __name__ == "__main__":
    main()

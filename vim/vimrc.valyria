scriptencoding utf-8
set encoding=utf-8

set nocompatible              " be iMproved, required
filetype off                  " required

" plugins
call plug#begin('~/.vim/plugged')

Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'tmhedberg/matchit'
Plug 'bronson/vim-trailing-whitespace'
Plug 'gerw/vim-HiLinkTrace'
Plug 'vim-scripts/visSum.vim'
Plug 'will133/vim-dirdiff'
Plug 'mhinz/vim-signify'
Plug 'scrooloose/syntastic'

call plug#end()
filetype plugin indent on


syntax on
set background=dark
set cursorline
set t_Co=256
colorscheme xoria256
set guifont=Monaco:h13

set colorcolumn=80
highlight ColorColumn ctermbg=235 guibg=#2c2d27
let &colorcolumn="80,".join(range(132,999),",")
"call matchadd('ColorColumn', '\%81v', 100)
highlight ExtraWhitespace ctermbg=red guibg=red

set laststatus=2
let g:airline#extensions#tabline#enabled = 1
let g:airline_theme = 'wombat'
"let g:airline_powerline_fonts = 1 " needs powerline fonts patch
"let g:airline#extensions#tabline#show_buffers = 1

let g:signify_vcs_list = [ 'git', 'svn' ]
let g:signify_disable_by_default = 1
nnoremap <leader>gt :SignifyToggle<CR>

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_sh_shellcheck_args = "-x -e 2086,1090,1091,2126"

"mouse visual block (ala MS Word) must :set mouse=a
nmap <C-LeftMouse> <LeftMouse><C-V>
vmap <C-LeftDrag>  <LeftDrag>
imap <C-LeftMouse> <LeftMouse><C-O><C-V>
vmap <C-LeftMouse> <Esc><LeftMouse><C-V>


set tabstop=4       " no. of spaces jumped upon tab , default 8 (ts)
set shiftwidth=4    " no. of spaces to use for each step of indent, default 8 (sw)
set softtabstop=4   " no. of spaces that a tab counts (sts)
set smarttab        " on tab, inserts blanks equal to shiftwidth(sta)
set expandtab       " expand the tab to appropriate no. of spaces (et)

set cindent         " (cin)
set autoindent      " use current lines indent level to next line (ai)
set smartindent     " intelligent guess of the new line indent    (si)
set paste

set magic           " special characters, always keep on
set title           " set title of window to filename
set noinsertmode    " makes the insert mode as NOT the default mode (noim)

set backspace=indent,eol,start  " Allows you to backspace over the listed character types
set whichwrap=bs    " allow <BS>/<SPACE> keys to move to previous/next lines at start/end of line(ww)
set wrapmargin=2    " no. of characters from right margin before wrapping starts (wm)
set wrap            " when text is longer than the width of window, text will wrap to next line
set linebreak       " break at the character that extends the width and not at the last character (lbr)

" Toggle line wrapping in normal mode:
nmap <silent><leader>w :set nowrap!<cr>:set nowrap?<cr>


set hlsearch        " highlight searches (hls)
set incsearch       " incremental search (is)
set ignorecase      " ignore case on searching (ic)
set smartcase       " acts smart about cases (scs)
set showmatch       " When a bracket is inserted, briefly jump to the matching one
nnoremap <silent> <BS> :nohlsearch<CR>  " trun off search highlight matches

"set listchars=tab:>-,extends:»,precedes:«,trail:•
set listchars=tab:▸\ ,extends:»,precedes:«,trail:•,eol:¬,nbsp:_
set nolist
nmap <leader>l :set list!<CR>
"let &showbreak=''

" edit compressed files
augroup gzip
    autocmd!
    autocmd BufReadPre,FileReadPre     *.gz set bin
    autocmd BufReadPost,FileReadPost   *.gz '[,']!gunzip
    autocmd BufReadPost,FileReadPost   *.gz set nobin
    autocmd BufReadPost,FileReadPost   *.gz execute ":doautocmd BufReadPost " . expand("%:r")
    autocmd BufWritePost,FileWritePost *.gz !mv <afile> <afile>:r
    autocmd BufWritePost,FileWritePost *.gz !gzip <afile>:r
    autocmd FileAppendPre              *.gz !gunzip <afile>
    autocmd FileAppendPre              *.gz !mv <afile>:r <afile>
    autocmd FileAppendPost             *.gz !mv <afile> <afile>:r
    autocmd FileAppendPost             *.gz !gzip <afile>:r
augroup END

" perl programs
autocmd BufEnter *.pl set syntax=perl
autocmd BufEnter *.pl set ai si cin formatoptions=croql
autocmd BufLeave *.pl set nosi nocin formatoptions=tcq
autocmd BufEnter *.pl set comments=b:#
autocmd BufLeave *.pl set comments=sr:/*,mb:*,el:*/,://,b:#,:%,:XCOMM,n:>,fb:-

" python programs
autocmd BufEnter *.py,*.psp set syntax=python
autocmd BufRead  *.py,*.psp set smartindent cinwords=if,elif,else,for,while,try,except,finally,def,class
autocmd BufRead  *.py,*.psp inoremap # X#
autocmd BufRead  *.py,*.psp set tabstop=4
autocmd BufRead  *.py,*.psp set shiftwidth=4
autocmd BufRead  *.py,*.psp set softtabstop=4
autocmd BufRead  *.py,*.psp highlight BadWhitespace ctermbg=red guibg=red
autocmd BufRead  *.py,*.psp match BadWhitespace /^\t\+/
autocmd BufRead  *.py,*.psp match BadWhitespace /\s\+$/

" fortran programs
autocmd BufRead *.f*,*.F* let fortran_have_tabs=1
autocmd BufRead *.f*,*.F* let fortran_free_source=1
autocmd BufRead *.f*,*.F* let fortran_do_enddo=1

" c programs and header files
autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r set formatoptions=crql
autocmd BufLeave *.l,*.y,*.c,*.cc,*.h,*.r set formatoptions=tcq
autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r set comments=sr:/*,mb:*,el:*/,://
autocmd BufLeave *.l,*.y,*.c,*.cc,*.h,*.r set comments=sr:/*,mb:*,el:*/,://,b:#,:%,:XCOMM,n:>,fb:-
autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r map <F1> :!man <cword><CR><CR>
autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r map <F2> mpI/* <ESC>A */<ESC>`pj
autocmd BufEnter *.l,*.y,*.c,*.cc,*.h,*.r map <F3> mp^3x$xxx`pj
autocmd BufEnter *.l,*.y,?akefile*,*.c,*.cc,*.h,*.r map <F4> :!ctags -t *.{c,C,cc,h}<CR>
autocmd BufLeave *.l,*.y,*.c,*.cc,*.h,*.r unmap <F1>
autocmd BufLeave *.l,*.y,*.c,*.cc,*.h,*.r unmap <F2>
autocmd BufLeave *.l,*.y,*.c,*.cc,*.h,*.r unmap <F3>
autocmd BufLeave *.l,*.y,?akefile*,*.c,*.cc,*.h,*.r unmap <F4>

" tex & latex source files
autocmd BufEnter *.tex map <F1> {\
autocmd BufEnter *.tex map <F2> }
autocmd BufEnter *.tex map <F3> {\bf
autocmd BufEnter *.tex map <F4> {\it

" html source files
autocmd BufEnter *.htm* map <F1> <\
autocmd BufEnter *.htm* map <F2> >

set foldmethod=syntax
set nofoldenable "          dont fold by default

" Toggle between line numbers and relative line numbers
nnoremap <silent><leader>n :exe "set " . (&rnu == 1 ? "nornu" : "rnu")<cr>

set dictionary=/usr/bin/dict/ " specify the location of dictionary directory (dict)
set complete+=k               " keyword completion on CTRL-P or CTRL-N (cpt)

set ruler           " bottom line showing location of cursor (ru)
set showmode        " shows the mode one is in. INSERT or REPLACE (smd)
set novisualbell    " turn off visual bell (novb)
set noerrorbells    " turn off error bell or beep (noeb)

map <F5> :!make

" key mappings
"map 1 :1
map q :q!
map  :w
map $ :$
map + :se nu<CR>
map _ :se nonu<CR>
map <C-BS> X


nnoremap <leader>ew :e <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>es :sp <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>ev :vsp <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <leader>et :tabe <C-R>=expand("%:p:h") . "/" <CR>

nnoremap <silent> <leader>s :set spell!<CR>
set spelllang=en_us

set wildmode=list:full " completion mode used with character specified with wildchar (wim)
set wildchar=<TAB>     " character to type to start wildcard expansion in command line (wc)
set wildmenu
set wildignore=*.o,*.mod

nnoremap <leader>ev :vsplit $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<cr>


" visual shifting (does not exit Visual mode)
vnoremap < <gv
vnoremap > >gv
vnoremap . .gv

set ttyfast
